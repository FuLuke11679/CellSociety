package cellsociety.parser;

import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Author: Daniel Rodriguez-Florido
 * This is a class whose sole purpose is to parse the various types of rule strings
 */

public class GeneralConwayParser {


  public static void parseRuleString(String ruleString, Set<Integer> birthVals, Set<Integer> survivalVals) {
    if (ruleString.charAt(0) == 'B') {
      parseBSNotation(ruleString, birthVals, survivalVals);
    }
    else {
      parseSBNotation(ruleString, birthVals, survivalVals);
    }
  }

  /**
   * Extracts the rules from the rule string
   * @param ruleString The string that contains the birth and survival rules
   * @param birthVals The set that will contain the values of alive neighbors that warrant survival
   * @param survivalVals The set that will contain the values of alive neighbors that warrant birth
   *
   * CREDIT: The following function is AI generated by ChatGPT.
   */
  private static void parseBSNotation(String ruleString, Set<Integer> birthVals, Set<Integer> survivalVals) {
    // Regex to match "B<number>/S<number>"
    Pattern pattern = Pattern.compile("B(\\d*)/S(\\d*)");
    Matcher matcher = pattern.matcher(ruleString);

    if (matcher.matches()) {
      for (char c : matcher.group(1).toCharArray()) {
        birthVals.add(c - '0');
      }
      for (char c : matcher.group(2).toCharArray()) {
        survivalVals.add(c - '0');
      }
    }
  }

  private static void parseSBNotation(String ruleString, Set<Integer> birthVals, Set<Integer> survivalVals) {
    Pattern pattern = Pattern.compile("(\\d*)/(\\d*)");

    Matcher matcher = pattern.matcher(ruleString);
    if (matcher.matches()) {
      for (char c : matcher.group(1).toCharArray()) {
        survivalVals.add(c - '0');
      }
      for (char c : matcher.group(2).toCharArray()) {
        birthVals.add(c - '0');
      }
    }
  }

}
